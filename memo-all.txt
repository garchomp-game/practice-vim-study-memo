the_vim_way/0_mechanics.txt
>Gで行末まで一気に字下げ可能。
the_vim_way/2_foo_bar.js
A;の後にj.を繰り返すことで一気にセミコロンを置くことができる
A;j.j.
C=c$ カーソル位置から行末まで削除して挿入モード
s=cl 有効なエラーをすべて列挙する。:cl [from] [, [to]]
S=^C ccと同じ
I=^i 行頭に移動してから挿入モード
A=$a 行末に移動してから挿入モード
o=A<CR> 下の行に改行入れて挿入モード
O=ko 上の行に改行入れて挿入モード

TIP4: 色々なアンドゥ
.=u
;=,
n=N
&=u
@x=u(マクロ系)
the_vim_way/1_copy_content.txt
TIP8
vimではアンドゥの粒度を自分で制御できる。
インサートモードになってから抜けるまでが一つの粒度になるので、
定期的に入力モードから抜けておくと安全である。
目安としては、改行の単位、もしくは手が止まる単位で抜けておくのが
良いだろう。

TIP9: 変更を繰り返し可能なものにする
Vim Golfという考え方。

例えば、
db/x, b/dw,dawがあったとする。
ドットの公式にに当てはめると、最後に適応されるのはそれぞれ
x, dw, daw
である。dawは一つのコマンドとしてドットに記録されるので、このコマンドが
最も良いことが明白であろう。

タイブレーク 〜〜繰り返し性が一番高いのはどれか？〜〜

normal_mode/sprite.css
<C-x>で減算、<C-a>で加算。
数字指定もでき、カーソルが数字でない場合、次の数字までジャンプした上で
計算をする。
TIP11: 繰り返しで済むなら、回数を指定しない。
d2wや2dw出でいるところをあえてdw.とすることで、間違えて多めに
消したとしても、.で1単語ずつ戻せる。
繰り返して、実行して、元に戻せる。このマントラを忘れないように。

TIP12: 統合して統治せよ
vimが強力な理由は、オペレータとモーションの組み合わせから得られる。

オペレーター一覧
c=変更
d=削除
y=レジスタにヤンク
g~=大文字と小文字の入れ替え
gu=小文字化
gU=大文字化
zz=入力中のカーソルを画面中央に持ってく
>=インデントを深くする
<=インデントを浅くする
==自動インデント(ggG=とかよく使う)
!={motion}で指定される行を外部プログラムを使ってフィルタリングする
gc=コメント化(vim-plugからvim-commentaryを入れていた場合)

~~オペレーターは自由に定義することができる~~
詳しくは、:h map-operatorで確認してみよう。

~~挿入モード中に使えるショートカットキー~~

<C-h>: 一文字を削除(バックスペース)
<C-w>: 直前の１単語を削除
<C-u>: 行頭までを削除
<C-o>: ノーマル挿入モード

TIP15: 挿入モードから抜けないでレジスタから貼り付け
yt{char}: charで指定した文字の手前までコピーする
<C-r>: レジスタの内容を挿入する。
<C-v>{123}:10進コードで表現される文字を挿入
<C-v>u{123}:16進コードで表現される文字を挿入
TIP18: ダイアグラフによって特殊文字を挿入
<C-K>(小文字のK){char1}{char2}と入力すると、特殊文字の入力をすることができる。
ヘルプは、:h digraphs-defaultで見れる

TIP19: 置換モードで既存のテキストを上書き
f.R, b
Rでリプレイスモードに移行でき、入力したものが置き換わる。
h: tabstop
R: 置換モードに入る
gR: 仮想置換モードに入る
r{char}, gr{char}: ワンショットバージョン
※
R: 置換モードに入る
gR: 仮想置換モードに入る
r{char}, gr{char}: ワンショットバージョン
TIP20: ビジュアルモード
viwc: 一単語を選択して修正することができる。cwみたいなもん。
<C-g>でビジュアルモードと選択モードをトグル
基本的にvimのファンであれば、セレクトモードを使うことはあまりないだろう。

ビジュアルモードの有効化について
v: 文字指向のビジュアルモードを有効にする
V: 行指向のビジュアルモードを有効にする
<C-v>: ブロック指向のビジュアルモードを有効にする
gv: 直前のビジュアルな選択範囲を再度選択する
v, V, <C-v>はノーマルモードに戻るのにも使える
ビジュアルモード中にo: 上下の端にジャンプ

visual_mode/fibonacci-malformed.py
Vで行選択して範囲指定したら>でネストを下げる。
繰り返す場合はドットの公式で繰り返せば良い。
Vj>.

visual_mode/list-of-links.html
vitUとgUitの違いについて
vitUの場合、一度ビジュアルモードにしてから大文字にする。この場合、
ドットの公式を使った場合、影響範囲はタグ内の単語ではなく、
同じ位置にある、同じ文字数分だけ。
gUitは、オペレーターとモーションの組み合わ絵から成り立つ。
gU(アッパーケース)にする文字はit(タグ)の範囲内である。と指定することで、
単語の長さが変わっても、適切にタグ内の文字を大文字に変換することができる
chapter-table.txt
<C-v>3j: 矩形選択して3つ下の行まで選択
x..: 空白を削除＠2回繰り返し
gv: もう一度直前の範囲選択
r|: 選択範囲に縦棒を挿入
yyp: コピーして下の行に挿入
Vr-: 行選択して横棒を挿入

r{char}: カーソルの下の文字を直後に指定した{char}に置き換える

visual_mode/sprite.css
矩形選択して文字を置き換えるサンプル。コマンドの組み合わせ自体はシンプルだが、
翌々考えてみると少し挙動が特殊なようにも見える。

the_vim_way/2_foo_bar.js
矩形選択の範囲は、行末の長さがバラバラでも問題ない。
<C-v>jj$A;<ESC>

vimのコマンドラインモード
:[range]delete [x]: 指定した行を削除(してレジスタxに登録
:[range]yank [x]: 指定した行(をレジスタxに)ヤンク
:[line]put [x]: 指定した行の後にレジスタxをプット
:[range]copy {address}:指定した行を{address}で指定される行の下にコピー
:[range]mode {address}: 指定した行を、{address}で指定される行の下に移動
:[range]join: 指定した行を連結
:[range]normal {commands}: 指定した各業に対してノーマルモードの{commands}を実行
:[range]substitute/{pattern}/{string}/{flags}: 指定した各行で、{pattern}がアレばそれを{string}に置換
:[range]global/{pattern}/{cmd}:指定した行の内、{pattern}がマッチするすべての行で、Exコマンド{cmd}を実行

exコマンドについて
:print, :join, :delete等の多彩なコマンドがexから引き継がれて今もなお使えるようになっている。
:printの省略形として、数字の後にpをつけることができる

ex_mode/practical-vim
:2
:.,$p (:{start},{end})
ドットの公式で直前の指定行を選択することができる。

:%p : %ですべての行を選択する、つまり、すべての行をprintするということをしている。
ビジュアルモード中にコロン(:)を打つと:'<,'>というのが表示される。
これはビジュアルモードで選択された範囲を表している。
'<: ビジュアル選択範囲の戦闘
'>: ビジュアル選択範囲の最後の行
exコマンドのアドレスとしてパターンも指定できる。
:/<html>/,/<\/html>/p

タグの中身だけに対してexコマンドを実行する場合
:/<html>/+1,/<\/html>/-1p

:2
:.,.+3p
は、:2,5と等しい

ex_mode/shopping-list.todo
:copyについて
:6t.=6行目を現在行の下にコピー
:t6=現在行を6行目の下にコピー
:t.=現在行をコピー(ノーマルのyypと同じ)
:t$=現在行をファイル末尾にコピー
:'<,'>t0=ビジュアルな選択範囲をファイル先頭にコピー

:mで移動(moveコマンド)
Vjj
:'<, '>m$

ex_mode/foobar.js
先にA;で末尾にセミコロンやった後、一行下に下ってjVG。そして
:'<,'>normal .でドットの公式とビジュアルモードの合わせ技で一気に末尾にセミコロンを置く。
ビジュアルモードで選択した範囲にノーマルモードで実行するコマンドを複数回一括で実行することができる。
@:=直前のExコマンドを繰り返す

ex_mode/loop.js
:%s//<C-r><C-w>/g

TIP33
tailyに合わせて
*cw counter
で替えた後
:%s//<C-r><C-w>/g
で一括他の置換前の文字(*に登録されているもの)に一括置換することができる

q:=コマンドラインウィンドウを起動する
J=文字を連結する(数を指定することも可能)

:readと:write
:readで実行結果をバッファに書き込める
:wirteでバッファの内容を標準入力に渡したりファイルに書き込めたり。

ソートコマンドについて
/ex_mode/emails.csv
-k2と指定することで、2つ目のカラムを基準にソートする事ができる。

:2,$!sort -t',' -k2

シェル関係のコマンド
:shell=シェルを開始する
:!{cmd}=シェルで{cmd}を実行する
:read !{cmd}=シェルで{cmd}を実行し、その標準出力をカーソル業の下に挿入する
:[range]write !{cmd}=[range]で指定された行を標準入力として、シェルで{cmd}を実行する
:[range]!{filter}=外部プログラム{filter}で、指定した[range]をフィルタリングする

バッファ操作について
ワイルドカードを使ったりとかして複数のファイルを同時に開くことができる。
:bnや:bp以外にも<C-^>でバッファの切替をすることができる。
:bd [number] [number] ...で複数バッファを削除
:{number x},{number y}bdでxからyまでの番号を一括削除
:%bdで全てのバッファを削除することができる。
:lsや:argsはバッファの一覧を表示することができるけど、それぞれ特徴が若干違うことに注意

globを使ってファイルを指定することもできる。例えば
:args *.*
:args **/*.js
:args **/*.*
複数指定も可能
:args **/*.js **/*.css
ファイルを元に引数リストを使うこともできる。例えばチャプターリストを書いているファイルに入り
files/.chapters
:args `cat .chapters`
linuxコマンドのcatで表示させた内容をそのままバッファのファイル名として展開している。

隠しバッファについて
バッファを保存せずに:bn!とかで強制的に変更すると、:lsしたときに保存してない方に#hがつく。
カレントバッファは%aがつく
:set hiddenの設定を有効にすると、:qとか:nextとかを!(ビックリマーク)なしで実行することができる。
つまり警告が表示されなくなる。
ただ、基本的には有効にしなくてもいいだろう…個人的な好みだが…

TIP39: ウィンドウ分割について
<C-w>s=水平分割(縦)
<C-w>v=垂直分割(横)
:sp=水平分割で表示
:vsp=垂直分割で表示
:sp. :vsp. とすることでエクスプうローラー表示可能。
また、直接ファイルを開くこともできる(:vsp code/Main.java等)
<C-w>[hjkl]でウィンドウの移動が可能
<C-w>c=アクティブなウィンドウを閉じる
<C-w>o=アクティブなウィンドウ以外すべて閉じる

ワークディレクトリの設定を行うには:lcdコマンドを使う
一括で設定する場合は、:windo lcdコマンドを使うと良い。
詳細情報は、vimcastsの確認をする(休憩中に確認する)

タブのオープンとクローズについて
:tabeditで新しいタブを開くことができる(NvChadとかで結構使えそう)
※NvChadでも使えたが、NvChadではまた違う意味になるため使う場合は注意(バグの可能性もある？)

:tabclose=現在のタブを閉じるコマンド
:tabonly=現在開いているタブ以外のタブを閉じるコマンド
:tabm{number}=タブを移動する(先頭は0、それ以外は2以上)

:editで作業ディレクトリに対する相対パスで開くことができる
:edit code/to/path
※editは補完を使うことができる。もちろん:argsも
:edit %はバッファ内にあるファイルのパスを保管して表示してくれる
:edit %:h<TAB>とすることで、ファイル名を含めない状態でフォルダまでの
パスを保管してくれる

vimrcで
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
という設定を追加することで、%%で%:hと同じことができるようになる。つまり
:edit %%
でバッファのフォルダーまでのパスを補完してくれるようになる。

rails.vimというプラグインを使うことで、:set path+=app/**を
しなくていいだけでなく、その他様々なプラグインが用意されている。
これにより、:findでの検索がより便利になる。

vimのファイルエクスプローラーについて
-(ハイフン)で親ディレクトリに遡る。

:e .と:Eは似ているが、
:e .=カレントディレクトリ(:pwdで調べられる)を開く
:E=今開いているバッファを基準に開く

netrw中に
d=ディレクトリ作成
%=ファイル作成
D=ファイルやディレクトリ削除

:editで新規フォルダと一緒に作成した場合、とりあえず新規作成はするけど保存が
されない。

この場合は、外部コマンドのmkdirを呼び出せば良い。つまり

:edit hoge/huga/index.html
:!mkdir -p %:h
:write
で成功する。

ファイルが読み込み専用になっていて、sudoで上書きする必要がある場合、
:w !sudo tee % > /dev/null
で上書きすることができる。

カーソルの移動について
w=次の単語の先頭に前進
e=現在の単語もしくは次の単語の末尾に前進
b=現在の単語もしくは前の単語の先頭に後退
ge=前の単語の末尾に後退

:vertを前置することで横分割で開くことができる。
例えば、ヘルプの場合通常は
:h daw
だったのを、
:vert h daw
とすることで横に開ける。
これはヘルプに限らず、ターミナルやその他何かを開くときにも同じなので
色々と使えそう？

文字列検索について
fコマンドを思い出してみよう。
f{char}で検索ができるのであった。(TIP4参照)
繰り返し検索する場合は;(セミコロン)
進みすぎて戻る場合には,(カンマ)

f{char}=次にある{char}までカーソルを末尾方向に移動
F{char}=前にある{char}までカーソルを先頭方向に移動
t{char}=次にある{char}の直前の文字までカーソルを末尾方向に移動
T{char}=前にある{char}の直後の文字までカーソルを先頭方向に移動

削除コマンドについて
dt{char}={char}で指定された文字まで削除する。
dfd=行末まで削除する
筆者は、f{char}とF{char}はノーマルモードで、t{char}とT{char}はd{motion}やc{motion}と
組み合わせて使うことが多い。

例えば、d{motion}とf{char}の組み合わせだと、
df{char}、c{motion}とT{char}だとcT{char}といった具合
オペレーターとモーションの組み合わせてコマンドを使うことを改めて思い出そう。

/motions/search-haiku.txt
ビジュアルモードに入ってから検索を活用するパターン
例えば、文中の特定の文を消したかった場合、
削除開始位置にカーソルを置いた状態で、
v
/{char}<CR>h
d
とすることで、マッチした文字の先頭の手前から消すことができる
※たとえば、/geとした場合、先頭のgが検索対象になるので、
hでgの左に移動して、空白文字を含めて削除すると、ちょうどいい感じになる

motions/template.js
ビジュアルとモーションの組み合わせについて
vから初めて
i=インナー、内側指定
a=アラウンド、外側の空白も含めて指定
つまり
vi>=>の中身の内側あまで、<>は含まれない
va>=<>も含まれる

vitはタグが存在する行に移動する必要がある。
タグが下の行にある場合、タグの中身を指定するためには
vi>
it
として上げる必要がある。
タグごと変える場合は
vi>
at
とすれば良い。

a) ab=カッコで囲まれた範囲
i) ib=カッコの内側の範囲
a} aB=波括弧で囲まれた範囲
i} iB=波括弧の内側
(以後a省略)
i]
i>
i'
i"
i`
it(タグ)

ダブルクォーテーション内やタグの中を変更するサンプル
vi" text<ESC>
vit text<ESC>

iw=現在の単語(word)
aw=現在の単語+前後どちらかの空白
iW=現在の単語(WORD)
aW=現在の単語+前後どちらかの空白
is=現在の分
as=現在の分+前後どちらかの空白
ip=現在の段落
ap=現在の段落+前後どちらかの空行

d{motion}とc{motion}に付いての考察
一般的に、単語を消すときはdaw、
書き換えるときはciwが良いとされている。
これはいったい、どういうことなのだろう？
おさらいしてみよう。
iは、前後の空白を消さない。
aは、前後の空白を消すのであった。

dで単語を消したときは、余計は空白は消して空白の幅を揃えたい。
そのため、aで前後の余分な空白を取り去るといい感じになる。
一方、cで書き換えるときは、前後の空白消えてしまうと
単語の区切りが(英語の場合)わからなくなるので、
前後の空白を消さないiが相性がいい。
markのジャンプについて
``=現在のファイルで直前に行われたジャンプ以前にいた場所
`.=直前に変更された場所
`^=直前に挿入があった場所
`[=直前に変更もしくはヤンクが行われた場所
`]=直前に変更もしくはヤンクが行われた末尾
`<=直前のビジュアルな選択範囲の先頭
`>=直前のビジュアルな選択範囲の末尾

カッコのジャンプをした後、%で対となるカッコに移動したら、
``で直前のジャンプ移動に戻れる。
この後rでかっこの種類変更したら``で戻ってrで変えれば良い。
例えば、(hoge)があった場合、(にカーソル合わせて
%r}``r{
で変更ができる。

[count]G=指定した行にジャンプ
/pattern<CR>, /pattern<CR>, n, N=次もしくは前にあるpattern二ジャンプ
%=マッチするカッコにジャンプ
(, )=前の文(もしくは次の文)の先頭にジャンプ
{, }=前の段落{、もしくは次の段落}の先頭にジャンプ
H, M, L=画面の先頭、真ん中、末尾にジャンプ
gf=カーソル位置に記述されているファイル名にジャンプ
<C-]>=カーソル位置に記述されているキーワードの定義一にジャンプ
'{mark}、`{mark}=マークにジャンプ

ファイルのバッファ履歴は:jumpsで確認できる。
また、<C-o>と<C-i>で行ったり来たりできる。

なお、このテクニックはヘルプでも使える
ヘルプの定義先にジャンプ=<C-]>
ヘルプの定義元に戻る=<C-o> or <C-t>

変更履歴は、:changesで確認することができる。

TIP57: カーソル位置に記述されているファイル名のファイルにジャンプする
ファイルパスのところでgfとやるとそのファイルを開くことができるが…もし拡張子がない場合は、
:set suffixesadd+=.rb
とすることで拡張子の部分を追加した上で検索してくれる
マークについて
m{letter}コマンドでマークをすることができる。
ジャンプするときは`{letter}で可能。

一度マークを設定したら、vimを閉じた後もすぐにジャンプすることができるようになる。
_(アンダーバー)は、削除専用コマンドで、レジスタに影響を与えない。
このため、ヤンクした後削除したいものがあったら"_d{motion}とすれば良い。
※もちろんドットの公式も使える。

"{register}を前置することで、使いたいレジスタを指定できる。
指定がなかったら、無名レジスタが使われる。

例えば、"ayiwをしたら"aにヤンクしたデータが入り、"bddとすればbにデリートした行が入る。
"apとすればヤンクしたデータが、"bpとすればデリートしたデータが入る。
いつも使っているyyやddとかは、"{register}で指定していないので、
無名レジスタに格納されていたことになる。

"0はヤンクレジスタである。
つまり、yyとかyiwとかしたら、無名レジスタと"0レジスタにコピーされる。つまり……
yiwでコピーした後、置換したい部分にカーソルを合わせてdw
その後、h"0pとすれば貼付けすることができる。
無名レジスタはdwによって上書きされるが、"0に格納されている値は
ヤンクレジスタのため変更されない。これをうまく利用すればよい。

~~寄り道~~
複数の単語を置き換えるときはどうしたらいいんだろう？
今のところの考察の結果
the_vim_way/1_copy_content.txt
waitingをcontentに置き換えるのを３つやることを想定した場合
yiw(ヤンク)ww(移動)qa(マクロ開始)vepyiw(貼り付けて再ヤンク)
n@a(移動して実行)n@@(二回目移行は@@で省略)
つなげると
yiwwwqavepyiwn@an@@
……うん。これは明らかに違うな。もっといい方法ありそうだが
~~追記~~
スッキリ実行する方法わかりました。
yiwでコピーした後、wwで移動して、
cw
<C-r>0
<C-[>
で貼り付けて抜ける。
こうすることでドットの公式一回分になるので繰り返せる!!!

"%=現在のファイルのファイル名 
"#=代替ファイルのファイル名
".=直前に挿入されたテキスト

vepで貼付けをすることができる。
しかし、これには副作用があり、ビジュアルモード中にpを使うと、
getClipboard()とsetClipboard()の両方が呼ばれてしまう。
しかし、これを逆手に取ってうまく利用することもできる。
以下の文を入れ替えると考えたとき。
I like fish and chips.
実践vim記載のやり方は
fcdemmwwvep`mp
自分が思いついたやり方は、
fcyiwwwvepbbvep
マークを使うか否かの違いだ。
これについての考察は後ほどまとめてみる。

テキスト挿入について
pはカーソル位置にある文字の後ろにテキストが挿入される。
一方、Pはカーソル位置の前にテキストを挿入する。

以下のtrのタグだけをコピーしようとした場合、
<table>
	<tr>
		<td>Keystrokes</td>
		<td>buffer Content</td>
	</tr>
</table>

trにカーソルを合わせて、yVat gPで貼り付けができる。

y=ヤンク
V=行選択
at=タグを含めてコピー
gP=カーソルの上に行単位で貼り付ける

pasteについて。
ターミナルのvimでは、デフォルトでは貼り付けた時pasteオプションが無効になっている。
このため、オートインデントをONにすると、システムのクリップボードから
貼り付けた時(<C-A-v>)、インデントが崩れてしまう。

対策としては、pasteオプションをオンにすることでインデント崩れを回避できる。
:set pastetoggle=<f5>とすることで、f5でこの設定を切り替えすることが可能。
基本的にはoffにするべき。
TIP64: マクロの記録と実行
例えば以下のコードがあったとする。
foo = 1
bar = 'a'
foobar = foo + bar

fooのところにカーソルを合わせて
qaA;<C-[>Ivar<C-[>q
マクロ登録したら後は
j@aj@@
で繰り返すだけでvarとセミコロン入れられる。

the_vim_way/3_concat.js
上記では、前後の+にスペースを入れるのをやった。
デフォルトの例では２つだったが、これが５つになるとどうなるか?
;.を多くの回数繰り返さあ無いといけない。
;の条件に合致するものが変更範囲しか無いのであれば、qq;.q(qa;.qでも良い)で登録して
22@qなどとすることで、一気に複数回繰り返すことができる。
ここで繰り返す範囲を超えて対象のものが存在しない場合に限り多めの適当な数字を
採用できることに注意をする

~~補足~~
tildeopがオフの時、~を入力したらカーソル下の文字を大文字にし次に進む。
オンのときは、~{motion}となる。
なお、g~{motion}はオフのときでも動作する。

macros/consecutive-lines.txt
マクロでドットと単語の先頭を大文字にする場合、
qa
0f.(0が大事!)
r)
w~(単語の先頭に移動してカーソルの文字を大文字にして次へ)
jq(jで下に下がってからマクロ終了するところがポイント)
後は3@aでOK.
0で先頭にカーソルが行くようにしている。
これをマクロにおいては(正規化)と呼ぶ。
正規化をすることで、繰り返し性が高まる。
また、f.としている点にも注目。あえてl(エル)とするのではなく、
f.とすることで、桁数が増えても対応できる。これを安全装置と呼ぶ。
マクロを組む上では、正規化と安全装置を意識することが大事になってくる。

macros/broken-lines.txt
たとえば、複数の行の間にマクロが実行できない行があったらどうなるだろうか？
この場合は、マクロが実行できない行で失敗し、それ移行は実行されない。

そしたら、どうしたらいいだろうか？
答えは簡単で、Vで行選択ビジュアルモードになり、一番下まで選択する(VG)
そのあと:でビジュアルコマンドモードに入り、normal @aを実行すれば
対象の行全てにマクロが実行される。

qAを入力すると、qaのマクロに追記することができる。
マクロの内容がミスったとしても、追記するだけで済むので非常に便利。
しかし、これはあくまでもマクロの最後に追記すればなんとかなる場合に限る。

TIP69
macros/ruby_module/animal.rb
自分の予想
qagg/class<CR>VG>Omodule Rank<C-[>Goend<C-[>q
本に書いてあったやり方
qagg/class<CR>Omodule Rank<C-[>j>GGoend<C-[>q

ポイントは以下
・gg/class<CR>でどのファイルでも動作するように正規化をする
・OやVG>等を行う際、順番に気をつける(どのファイルでもちゃんと動作するように
するための安全装置)

これを:argdoで一気に複数ファイルに適応する場合は、
一度:edit!で変更前の状態に戻してからにする。
これを忘れてしまうと、:コマンド記録時とargdo実行時で合計２回実行されてしまう。
なお、一つずつ変更を加える場合は、qA:nextqを加えることで、１バッファずつ
適応することができる。
もちろん、22@aとすることで一気に複数に適応することもできる。
なお、複数のファイルに変更を加える場合は、
:wall
を使うと簡単(:argdo writeと:wallは厳密には別物)

TIP70: イテレーターを利用したマクロ
/macros/incremental.txt
行頭にインクリメントをしたかったとする。
ここではExpressionレジスタをつかって実現する(つまりvimscript)
~~プログラムのおさらい~~
let i = 1で初期化
インクリメントするときは
i++
ではなく
let i += 1
であることに注意。
つまりletは宣言だけではなく、変数操作をする際も必ず必要になる。
挿入モード中に<C-r>=とすると数式やプログラムの処理結果を入れることができる。
ここで変数iの値を入れると、iの値が入力される(<C-r>=i)
<CR>で数式やプログラムの入力を完了する。
以上のことを踏まえマクロを組むと以下のようになる。
:let i=1qaI<C-r>=i<CR>)<SPC><C-[>j:let i += 1<SPC>q
完成したら、後は99@aとかで実行すれば一気に複数行
連番を前置するマクロが完成する。

:reg {register} マクロの確認
:put {register} マクロ内容を貼り付ける

なお、これはレジスタに単に格納されているだけなので、
"{register}pでも貼り付け可能だが、これでは単に現在行に貼り付けるので、
カーソルにテキストがあった場合は思うような表示にならない。
そのため、:putコマンドを使うことで一行下に挿入できるようにしている。

編集が終わったら
0"ay$
でaレジスタに編集した内容を格納する。
後はこれを使って22@aとすれば一括で適切に変更ができる。

TIP72: -検索パタンが大文字/小文字を区別するかを予測する

ignorecase設定を有効にすると、vimの検索パターンで
大文字/小文字を区別しないようにできる。
:h ignorecase
この設定をすると、保管機能等に影響が出ることがあるため
注意が必要。

vimで使える正規表現の種類

magic検索 :h /magic
#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)
\vパターンスイッチ
\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})
\vパターンスイッチ+\x文字クラスも仕様
:h /character-classes
\v#(\x{6}|\x{3})

一般的に、正規表現を検索したい場合は\vパターンスイッチ、
テキストを検索したい場合は\Vリテラルスイッチを使う。
以下ヘルプの早見表コピペ

例:
  \v	   \m	  | \M	    \V	 	マッチするもの ~
		'magic'    | 'nomagic'
--------------------------------------------
	  a	   a	   | a	     a	  	リテラルの 'a'
	  \a	  \a	  | \a     \a	 	何かの英字 1 文字
	  .	   .	   | \.	    \.	 	何か 1 文字
	  \.	  \.	  | .	     .	  	リテラルのドット
	  $	   $	   | $	     \$	 	行末
	  *	   *	   | \*	    \*	 	直前のアトムの繰り返し
	  ~	   ~	   | \~	    \~	 	直近の置換文字列
	  ()	  \(\) | \(\)   \(\)	アトムとしてグループ化
	  |	   \|	  | \|	    \|	 	マッチ無し: 選択の区切り
	  \\	  \\	  | \\	    \\		 リテラルのバックスラッシュ
	  \{	  {	   | {	     {		  リテラルの波カッコ

TIP75: カッコを使って部分マッチをキャプチャする
patterns/springtime.txt
連続して重複している単語を探すには
/\V<(\w+)\_s+\1>
theが連続して続いている部分を探す。

TIP76: 単語の境界を指定する。
境界を指定するために、単語境界デリミタというものがある。
これに関しては、単語境界デリミタとして<>を使うことができる。
これらを利用して
/\v<the><CR>
とすることで、theという単語を明確に検索することができる。

/\v(And|D)rew Neilと検索すると、(And|D)のどちらかが
\1にキャプチャされることになる。
このキャプチャをしないようにするには、カッコの頭に%をつければ良い。
つまり、
/\v%(And|D)rew Neil
とすればキャプチャせずに検索を実行することができる。
これをうまく利用して、
/\v(%(And|D)rew) (Neil)
とすると、Andrew/DrewとNeilの名前を入れ替えるといった事をする時、
\1にはAndrewかDrewが、\2にはNeilが入る。

\zsと\zeの使い分けについて
\zsはパターンの開始地点の設定
\zeは終了地点の設定。
例えば、これを検索で応用すると、/practical \zsvimで実行した場合、
practicalの直後にあるvimがハイライト表示されることになる。
内部としては、practical vimが検索されているが、practicalの部分は
検索結果表示時には除外される。

例えば以下の文があったとする
Match "quoted words"---not quote marks.
この分のダブルクォーテーションの中を検索する時、zeやzsを活用すると
便利な検索ができるようになることがある。

/\v"\zs[^"]+\ze"<CR>
これはこのように書き直すこともできる
/\v"@<=[^"]+"@=<CR>

TIP78: 文字をエスケープ
patterns/search-url.markdown
urlを検索するには、以下のように、必要なところは
適宜バックスラッシュでエスケープしてあげる必要がある。
\Vhttp:\/\/vimdoc.net\/search\?q=\/\\\\

escape({string}, {chars})で、エスケープ文字を指定することができる
これを使って、いちいちエスケープ処理しなくても
/\V<C-r>"=escape(@u, '/\)<CR>
でエスケープ処理をしてくれた上で検索してくれる。
@uの中身は書き換わらないので安心。

TIP80: マッチを強調表示する
:h hlsearch hls
:set hlsとすることで、ハイライトを有効にすることができる。
:nohで一時的に無効、:set nohls:set hlsとすることで、
ハイライトを有効にすることができる。
:set nohlsで無効化すること尾ができる

<C-l> 再描画
TIP81: 実行前に最初にマッチするものをプレビュー
検索フィールドプレビュー
:h incsearch
例えば、以下の文に対して/carrと入力してみる
The car was the color of a carrot
/car入力地点では、先頭のcarにヒットするが、その後続けて
rを入力したら、carrotの先頭にカーソルが移動する。
この時点で<ESC>を押したら最初にカーソルがあった場所に戻る。
これのメリットは、例えば検索対象のページがかなり下の方にあり
画面から離れていたとしても、<ESC>を押せば元の場所に戻ることができる。
つまり、いちいちマークしなくても調べるだけなら手軽にできる。

TIP82: 現在のパターンにマッチするものの数を数える
:%s///gnを使うと、前回検索したパターンに一致するキーワードの数を
カウントしてくれる。

:%sは置換するコマンド。
このコマンドは
:%s/{検索文字}/{置換文字}/{ビジュアルモーション}
で構成されている

※[n]	マッチの個数を表示し、実際には置換を行わない。

この内、置換文字は省略可能。
つまり、:%s///gnとすると、（多分）検索レジスタが検索対象となり、そのまま順列に検索すると。

TIP83: 検索のマッチの末尾にカーソルをオフセットする
検索は
/{text}/{motion}
といった使い方ができる。これを利用して
/lang/e
でlangの末尾(g)にカーソルを移動することで、
単数形、複数形問わず安全に置換することができる。

TIP84: マッチ全体に対して処理を行う
search/tag-heirarchy
XhtmlとXml両方含めるためには
/\vX(ht)?ml
でできる、これに大文字小文字の区別を矯正する\Cを入れて
/\vX(ht)?ml\C
とすることで正確な検索ができる。
これに対してgU//eで大文字にする
分解すると
gU 大文字
// 前回の検索箇所
e  検索対象の単語の末尾

※gU{text|searchResult}{motion}

からなる。
あとは//<CR>.で繰り返せる

~~寄り道~~
ちなみにマクロでやる場合は
qn//<CR>.q
のあと、@nで繰り返すことができる。

TIP85: 検索履歴を繰り返しながら複雑なパターンを作り上げる
search/quoted-strings
例えば、シングルクォートをダブルクォートに替えたかったとする。
ここでポイントになるのは、アポストロフィーの'は変えずに、
囲うための'だけを変更すること。

答えは以下のようになる
/\v'(([^']|'\w)+)'
:%s//"\1"/g

[^{char}] char以外の文字のみヒット
{char}\w charの後に単語(w[ord])が続く場合のみヒット
カッコについては、おそらく一番外側の()が\1で、
その中にあるカッコが\2として対応しているはず（多分…）

TIP87: 置換コマンド
:substituteコマンドについての紹介
:[range]s[ubstitute]/{pattern}/{string}/[flags]

フラグについては、:h s_flagsを参照
特殊な意味を持つ文字については:h sub-replace-specialを参照

TIP89: 一括置換について
:%s/pattern/text/g
の
% Y軸
g X軸
である。
注意したいのは、gは行の中でヒットしたものが対象なので、
ファイル全体ではない。
%だけだと、行の先頭だけが対象であることに注意
TIP89: 置換のたびに確認する
確認を逐一するためには、cフラグを使うと良い
example :%s/{pattern}/{text}/gc

TIP90: 直前の置換パターンを流用する
:%s/\v'(([^']|'\w)+)'/"\1"/g
このコマンドは、以下の２つに分解できる
/\v'(([^']|'\w)+)'
:%s//"\1"/g
検索コマンドと置換コマンドを分割して考えたほうが、
見通しが良くなるだけでなく、修正もしやすい。
検索部分だけを集中して修正すればいいので、影響範囲とか気にせず
何度でも実験できる。

また、パターンは全部記述しなくても別にいいわけで、
単に*に当たる部分をvimスクリプトを使ってマッピングしてあげれば
楽に検索できるようになるわけだ。

コマンドモードから直前の検索を呼び出したいのであれば
<C-r>/
で呼び出すことができる、検索とコマンドを統合したいときは
これを使えば合体することができる。

TIP91: レジスタの内容を使って置換を行う
~~参照渡しと値渡しについて~~

値渡し：<C-r>{register}
参照渡し：\=@{register}
・実はマクロは、単にレジスタにコマンドが格納されているだけ
・@を使うことで、値を参照することができる。

~~比較してみよう~~
:%s/Pragmatic Vim/Practical Vim/g
これを以下のコマンドシーケンスと比較してみよう。
:let @/='Pragmatic vim'
:let @a='Practical Vim'
:%s//\=@a/g
ちなみに、ここで言う@a='practical Vim'は、"ayとかでヤンクしたのと
同じ状態。つまり、
Practical Vim
の先頭にカーソルがあった場合、
fPvee"ay
した状態と同じになる。

この方法のいいところは、レジスタaの内容を変えるだけで、様々な
置換ができるようになることだ。
変えるべき場所は@/と@aだけ、@/は単純に普通に検索していれば
自動的に格納される。

TIP92: 直前の置換コマンドを繰り返す
:%sとやるべき所、間違えて:sとしても心配はいらない。
g&で繰り返せばいいだけ。
:h g&
g&は、%s//~/&と同義である。

これを使って、
substitution/mixin.js
:%s/Name/Number/g
とか間違えてやっちゃっても、
u
で修正して、
gv
:&&
で戻せる。
&&で直前の置換コマンドを実行することができる。

~~寄り道~~
ちなみに何だけど、これを本来一発で実行するためには
VjjyPgv:s/Name/Number
で実行できる

TIP93: 部分マッチを使ってCSVのフィールドを入れ替える
\n記法を使うことで、位置を入れ替えたりとかもできる。

これを活用して
substitution/subscribers
\v^([^,]*),([^,]*),([^,]*)
%s//\3,\2,\1
といった使い方ができる。

TIP94: 置換時に算術演算を行う
タグの数字の部分だけを検索するには、
\v\<\/?h\zs\d
といった方法で検索することで実現できる。
\/?で/(スラッシュ)があった場合のみヒットするようにしている。

この検索結果を使って置換する方法は以下の通り。
%s//\=submatch(0)-1/g
submatch関数を使うことで、数値を取得することができる。
引数は配列のindexを指定する。Java風に例えるなら
public String submatch(int index)
といったところだろうか。
~~個人的な考察~~
vim scriptはjsと同じで、厳密な型の縛りはないように思える。
よって、int = String - intも成立しているような挙動になってるかもしれない。

TIP95: 2つ以上の単語を入れ替える
The dog bit the man.
というテキストのdogとmanを入れ替えたかった時、
\v(<man>|<dog>)
で検索してから
%s//\=swapper[submatch(1)]/g
で変換することができる。なお、このswapperには予め
let swapper={"dog":"man", "man":"dog"}
という連想配列を作っておく必要がある。
このサンプルはあくまでも素案であり、最適解ではない。
もっと工夫することもできる。

別解
\v(<dog>)([^m]*)(<man>)
で検索してから
%s//\3\2\1/g
で置換することもできる。
TIP96: 複数ファイル間で検索と置換を行う

substitution/refactor-project/*
:cdで移動したあと args **/*.txtでテキスト系を開く。
これらのファイルに対して一括で置換する方法は、
argdo %s//Practical/ge
でできる。
eフラグはエラーを出ないようにすることができる。
ちなみに、このやり方は、乱射的なやり方とも言える。
的を絞ったやり方もある。

独自コマンドを定義したものをプラグインとしてインストール、
もしくはvimrcに追記してQargsコマンドを定義して利用することで、
簡単に目的を絞った置換ができる。
Quickfixfilenames()メソッドの処理詳細については後で深く検討するので、
いったんvimrcに残しておく。

TIP98: パターンを含む行を削除する
global/episodes.html
例えば、タグの中のテキストだけを残したかったとする。
その場合は、
/\v\<\/?\w+>
で検索した後、
:g//d
で中身のテキストだけを残すことができる。
:deleteコマンドは対象の行を削除するので、削除対象の行をマークできれば
とりあえずOK。なので、タグの先頭部分だけをマッチするようにしている。
ちなみに、:vコマンドを実行すると、:gコマンドと逆のことをする。
:h :v
TIP99: レジスタにtodoアイテムを収集する
例えば、todoリストからtodoの行だけを抜き取りたかったら、
qaq
でレジスタの内容を空にしてから
g/TODO/yank A
でレジスタaに追記すればいいだろう。
TIP100: cssファイル中のルールのプロパティをアルファベット順に並べ替える
一つのブロックをソートする場合は
vi{
:sort
でできる。
ではこれを複数行で適応するにはどうしたらいいか？
答えは、
:g/{/ .+1,/}/-1 sort
となる。
TIP102: ctagsと連携できるようにvimを構成する
:set tags?で現在のtagsの設定を確認することができる。
:!ctags -Rで、外部コマンドのctagsを使って、サブディレクトリを再帰して、
すべてのファイルのインデックスを作成する。
ctagsを活用することで、クラスやメソッドの定義ジャンプ等が
簡単にできるようになるのでとても便利。
NvChadのjdtlsにはどうやらこの機能がデフォルトで入っているようだ。

TIP103; vimのタグナビゲーションコマンドを使ってキーワード定義に移動する
<C-]>でctag定義先にジャンプ
<C-t>か<C-o>でもどる。
複数定義ある(インターフェースやスーパークラスで継承しているなど）の場合は、
g<C-]>で一覧を表示させることができる。
また、普通に<C-]>をやってから後出しで
:tselect
とすることで同じ形で一覧を表示することができる。
なお、これらはexコマンドにtを前置したもので、:tnext,:tlast,:tfirst
といったコマンドを使うこともできる。
なお、
:tjump /phone$
で、phoneで終わる定義にジャンプすることができる。
TIP105: クイックフィックスリストをブラウズする
:cnext 次の要素にジャンプ
:cprev 前の要素にジャンプ
:cfirst 最初の要素にジャンプ
:clast 最後の要素にジャンプ
:cnfile 次のファイルの最初の要素にジャンプ
:cpfile 前のファイルの最後の要素にジャンプ
:cc N N番目の要素にジャンプ
:copen quickfixウィンドウをオープン
:cclose quickfixウィンドウをクローズ

~~寄り道~~
ターミナルモードでジョブモード(インサートモード)中に
<C-w>"{register}
で貼り付けることができる。

TIP110: vimの内部検索エンジンを使ってgrepする
:vim[grep]で検索する場合、//といった省略記法は使えない。
そのため、前回の検索を流用するには
:vim /<C-r>// **
とする必要がある。
TIP111: vimキーワード自動補完機能とは
ignorecaseオプションが有効な場合、
vimの検索コマンドは大文字とこもおじを同じ文字として扱う。
これは自動補完も同じく区別しなくなる。
infercaseを有効にすればこの問題を解決することができる
:h infercase
自動補完を起動するあれこれ
<C-n> 汎用のキーワード
<C-x><C-n> 現在のバッファのキーワード
<C-x><C-i> インクルードされているファイルのキーワード
<C-x><C-]> tagsファイルのキーワード
<C-x><C-k> 辞書のルックアップ
<C-x><C-l> 行全体を補完
<C-x><C-f> ファイル名を補完
<C-x><C-o> オムニ補完

TIP112: 自動補完のポップアップメニューを操作する
<C-n> 単語リストから次のマッチを使う(next match)
<C-p> 単語リストから前のマッチを使う(previous match)
<Down> 単語リストから次のマッチを選択する
<Up> 単語リストから前のマッチを選択する
<C-y> 現在選択されているマッチを入力する(yes)
<C-e> 元々入力していたテキストに戻る(exit from autocompletion)
<C-h>|<BS> 現在のマッチから一文字削除する
<C-l> 現在のマッチから一文字追加する
{char} 補完を中止して{char}を入力する
詳細については
:h popupmenu-completion
ちなみに、筆者のおすすめは<C-n><C-p>。
自動補完を起動した後、単語リストの前の要素を選択しスタート地点へ戻る。

TIP113: キーワードの定義元を把握する
自動補完リスト作成で最も簡単な方法は、<C-x><C-n>。
:h compl-current
~~補足~~
別の検索方法として、
:h ctrl-x_ctrl-n
がある。このようにctrlが続く場合は
:h ctrl-{char}_ctrl-{char}
という感じで、間にアンダーバーを入れる。

汎用の自動補完のカスタマイズは、
:set complete-=(+=)w b u t i
のいずれかでできる。
それぞれのオプションの詳細については
:h complete
を参照のこと
TIP114: 辞書を使って単語を自動補完
vim補完の辞書についてのヘルプは
:h compl-dictionary
で確認することができる。
単語リストの有効化方法は
:set spell
TIP115: 行をまるごと自動補完
<C-x><C-l>で行まるごと自動補完することができる。
TIP116: ファイル名の自動補完
<C-x><C-f>でファイル名の自動補完ができる。
<C-x><C-f>をした後に選択した後、また<C-x><C-f>をすると、
続きのパスも補完することができる。
auto_complete/webapp/public/index.html
:cdでwebappに一旦移動し、その後publicフォルダに移動。
その後srcで
js/<C-x><C-f>
でファイル名を保管することができる
直前のディレクトリに戻るには
:cd -
で戻ることができる。ヘルプは以下
:h cd-
TIP117: コンテキストに合わせて自動補完を行う
標準サポートされているものについては
:h compl-omni-filetypes
で確認することができる。
TIP118: 作業結果にスペルチェッカをかけてみよう
:set spellでスペルチェッカを起動することができる。
ジャンプの仕方については
:h ]s
等を参照の事。
スペルチェッカを起動した状態で、
z=
を実行すると置換候補の一覧が表示される。
]s 次のスペルミスにジャンプ
[s 前のスペルミスにジャンプ
z= 現在の単語の修正候補を表示
zg 現在の単語をスペルファイルに追加
zw 現在の単語をスペルファイルから削除
zug 現在の単語に関してzgコマンドもしくはzwコマンドをアンドゥ

TIP119: 別の辞書を使用する
スペルチェッカを有効化すると、デフォルトでは英語辞書に対して
単語の比較が行われる。
spelllangオプションを設定することでこれらを変更可能
:h spelllang
TIP120: スペルファイルに単語を追加する
spellfileオプションを使用して、zg/zwコマンドで追加/削除される単語を
vimが記録するファイルのパスを指定するコットができる
:h spellfile
例えば、以下のファイルを読み込ませることで、独自のスペル定義を
追加することができる。
spell_check/spellfile
TIP121: スペルミスを挿入モードで修正する。
1z=という形でスペルの修正を手早くすることもできるが、
<C-x><C-s>
でインサートモード中に一覧を表示することもできる。

付録A: 自分の好みに合わせてvimをカスタマイズ
すべてのオプションは、
:h option-list
で確認することができる。
基本的には
:set option
でセットする。無効化するときは
:set nooption
といった感じで、noを前置する。
また、
:set option!
でトグルし、
:set option?
で現在のオプションの状態を確認することができる。
:set option&
とすることで、オプションを初期状態に戻す事ができる。
オプションによっては、数字を指定するものもある。
たとえば、
:set tabstop=2
といったものや
:set ts=2 sts=2 sw=2 et
といった感じで複数の代入もできる
オプションは省略できるものが幾つか存在する。
ウィンドウ、もしくはバッファに適応したかったら、
:setlocal
を使うとよい。例えば
:bufdo setlocal tabstop=4
といった使い方ができる。
ウィンドウの場合は
:windo setlocal number
などとすれば良い

A.3 カスタマイズを特定のファイルタイプに適応する
autocmd宣言を使って、イベントを指定することができる
customizations/filetype-indentation.vim

